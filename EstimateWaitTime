package SMTravelSimulation;
import simulationModelling.ExtSequelActivity;
import simulationModelling.SequelActivity;
/*
 * Extended Sequel Activity EstimateWaitTime
 */
public class EstimateWaitTime extends ExtSequelActivity{
	
	SMTravel model;
	private Call icCall;

	
	 // Constructor
	EstimateWaitTime(SMTravel model, Call icCall){
		this.model = model;
		this.icCall = icCall;	
	}
	
	public void startingEvent() {
		icCall.startWaitTime = model.getClock(); 	
	}
	
	protected double duration() {
		return Constants.EWTVOICEDURATION;
	}
	
	public int interruptionPreCond(){
		int interruptID = 0;
		if((model.udp.CanServiceCall(icCall.uCuType) != null) && (CheckEmptyQueue(icCall.uCuType) == true)) 
			interruptID = 1;
		
		return interruptID;
	}
	public void interruptionSCS(int interruptID){
		interruptID = interruptionPreCond();
		if (interruptID == 1) {
			model.spInsertQue(model.qCallLine[icCall.uCuType], icCall);
			model.spTerminate();
		}
	}
	protected void terminatingEvent() {
		if(CheckRenegingCall(icCall.uCuType) == true) {
			model.spLeave(icCall);
		}
		else {
			model.spInsertQue(model.qCallLine[icCall.uCuType], icCall);
		}
	}

 /*------------------------------------   Embedded UDPs   ----------------------------------------------*/
	/* Method: CheckRenegingCall
	 * Description: Compare estimated wait-time and customers tolerance, to determine the reneging
	 * Parameter: Customer Type
	 * Return: true if the customer drops the call, false otherwise
	 */
	public boolean CheckRenegingCall(int uCuType) {
		
		double waitTime = -1; //// not sure about this, we don't have wait time anywhere
		if(uCuType == Constants.REGULAR) {
			waitTime = Constants.EWTDURATION * model.qCallLine[Constants.GOLD].n + model.qCallLine[Constants.SILVER].n + model.qCallLine[Constants.REGULAR].n;
		}
		if(uCuType == Constants.SILVER) {
			waitTime = Constants.EWTDURATION * model.qCallLine[Constants.GOLD].n + model.qCallLine[Constants.SILVER].n;
		}
		if(uCuType == Constants.GOLD) {
			waitTime = Constants.EWTDURATION * model.qCallLine[Constants.GOLD].n;
		}
		if(model.rvp.uWaitTMTolerance(uCuType) >= waitTime) 
			return false;
		else
			return true;
	}	
	
	/* Method: CheckEmptyQueue
	 * Description: checks the queue to find empty place
	 * Parameter: Customer Type
	 * Return: true if there is empty spot, false otherwise
	 */
	public boolean CheckEmptyQueue(int uCuType){
		if(model.qCallLine[uCuType] == null)
			return true;
		else
			return false;
		
	}
}
